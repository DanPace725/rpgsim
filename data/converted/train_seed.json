[
    {
        "id":  "seed:def/ontology",
        "instruction":  "Define the ONTOLOGY primitive in RP-Lang terms.",
        "input":  "",
        "output":  "Primitive: ONTOLOGY. Role: classify and name entities; establish identity and membership so relations know what they are operating on. Typical relation: ONTOLOGY(entity, kind=Prey, tags=[green]).",
        "metadata":  {
                         "source":  "Relational Primitives/Rplang.md",
                         "tags":  [
                                      "definition",
                                      "ontology"
                                  ],
                         "split":  "train",
                         "difficulty":  "easy"
                     }
    },
    {
        "id":  "seed:def/geometry",
        "instruction":  "Define the GEOMETRY primitive in RP-Lang terms.",
        "input":  "",
        "output":  "Primitive: GEOMETRY. Role: spatial/structural organizationâ€”adjacency, containment, distance, layout. Typical relation: GEOMETRY(button inside panel, padding=8) or GEOMETRY(predator near prey, radius=80).",
        "metadata":  {
                         "source":  "Relational Primitives/Rplang.md",
                         "tags":  [
                                      "definition",
                                      "geometry"
                                  ],
                         "split":  "train",
                         "difficulty":  "easy"
                     }
    },
    {
        "id":  "seed:def/dynamics",
        "instruction":  "Define the DYNAMICS primitive in RP-Lang terms.",
        "input":  "",
        "output":  "Primitive: DYNAMICS. Role: change of state over timeâ€”movement, energy gain/loss, growth, decay. Typical relation: DYNAMICS(prey, velocity=rand_walk) or DYNAMICS(resource, regrow_after=100 ticks).",
        "metadata":  {
                         "source":  "Relational Primitives/Rplang.md",
                         "tags":  [
                                      "definition",
                                      "dynamics"
                                  ],
                         "split":  "train",
                         "difficulty":  "easy"
                     }
    },
    {
        "id":  "seed:def/constraint",
        "instruction":  "Define the CONSTRAINT primitive in RP-Lang terms.",
        "input":  "",
        "output":  "Primitive: CONSTRAINT. Role: boundary conditions and clampingâ€”min/max, collision bounds, conservation. Typical relation: CONSTRAINT(agent, bounds=[10,590]) to keep entities on-screen.",
        "metadata":  {
                         "source":  "Relational Primitives/Rplang.md",
                         "tags":  [
                                      "definition",
                                      "constraint"
                                  ],
                         "split":  "train",
                         "difficulty":  "easy"
                     }
    },
    {
        "id":  "seed:def/epistemic",
        "instruction":  "Define the EPISTEMIC primitive in RP-Lang terms.",
        "input":  "",
        "output":  "Primitive: EPISTEMIC. Role: sensing/knowledge of other entities or world state. Typical relation: EPISTEMIC(prey senses predator, radius=50) or EPISTEMIC(agent sees resource positions).",
        "metadata":  {
                         "source":  "Relational Primitives/Rplang.md",
                         "tags":  [
                                      "definition",
                                      "epistemic"
                                  ],
                         "split":  "train",
                         "difficulty":  "easy"
                     }
    },
    {
        "id":  "seed:def/meta",
        "instruction":  "Define the META primitive in RP-Lang terms.",
        "input":  "",
        "output":  "Primitive: META. Role: rules about rulesâ€”handlers that watch events/relations and create/modify others. Typical relation: META(on_button_click create Predator entity).",
        "metadata":  {
                         "source":  "Relational Primitives/Rplang.md",
                         "tags":  [
                                      "definition",
                                      "meta"
                                  ],
                         "split":  "train",
                         "difficulty":  "easy"
                     }
    },
    {
        "id":  "seed:translate/natural-to-rp",
        "instruction":  "Translate this natural spec into RP relations.",
        "input":  "A panel contains two buttons. Clicking â€œAdd Preyâ€ spawns a prey agent at a random position; clicking â€œAdd Predatorâ€ spawns a predator. Agents stay within the 10â€“590 bounds.",
        "output":  "Entities: panel P, buttons Bp (Add Prey), Bd (Add Predator). Relations: GEOMETRY(Bp inside P, padding=8); GEOMETRY(Bd inside P, padding=8, below= Bp). CONSTRAINT(P, bounds=[10,590]); CONSTRAINT(Bp, bounds=[10,590]); CONSTRAINT(Bd, bounds=[10,590]). META(on_click Bp =\u003e create entity kind=Prey at rand_pos within bounds); META(on_click Bd =\u003e create entity kind=Predator at rand_pos within bounds). ONTOLOGY tags on created entities set their kind.",
        "metadata":  {
                         "source":  "Relational Primitives/Ecosystem demo.md",
                         "tags":  [
                                      "translation",
                                      "geometry",
                                      "constraint",
                                      "meta",
                                      "ontology"
                                  ],
                         "split":  "train",
                         "difficulty":  "medium"
                     }
    },
    {
        "id":  "seed:translate/rp-to-natural",
        "instruction":  "Explain this RP world in natural language without leaving the primitives.",
        "input":  "Entities: Predator p1, Prey q1. Relations: GEOMETRY(p1 near q1, radius=80); EPISTEMIC(p1 senses q1, radius=80); DYNAMICS(p1, chase_target=q1, speed=2); DYNAMICS(q1, flee_target=p1, speed=1.5); CONSTRAINT(p1, bounds=[10,590]); CONSTRAINT(q1, bounds=[10,590]).",
        "output":  "A predator and a prey exist. Geometry sets a proximity radius between them; epistemic sensing lets the predator know the preyâ€™s position. Dynamics make the predator move toward the prey and the prey flee. Constraints keep both inside the 10â€“590 box.",
        "metadata":  {
                         "source":  "Relational Primitives/Ecosystem demo.md",
                         "tags":  [
                                      "explanation",
                                      "geometry",
                                      "epistemic",
                                      "dynamics",
                                      "constraint"
                                  ],
                         "split":  "train",
                         "difficulty":  "medium"
                     }
    },
    {
        "id":  "seed:reason/evaluator-step",
        "instruction":  "Run one evaluator step. Show resulting state changes.",
        "input":  "Entities: Resource r1 at (100,100) with active=True; Prey q1 at (102,103), energy=10. Relations: GEOMETRY(q1 near r1, radius=5); DYNAMICS(q1, energy_drain=1); DYNAMICS(r1, regrow_after=100); CONSTRAINT(r1, consumed_when_near=True).",
        "output":  "Step result: GEOMETRY detects proximity. CONSTRAINT marks r1 consumed â†’ r1.active=False. DYNAMICS on q1: energy=9 after drain, plus grazing bonus (+2) from consumption â‡’ energy=11. DYNAMICS on r1 schedules regrow timer toward 100 ticks (state regrow_counter=1).",
        "metadata":  {
                         "source":  "Relational Primitives/Ecosystem demo.md",
                         "tags":  [
                                      "reasoning",
                                      "geometry",
                                      "constraint",
                                      "dynamics"
                                  ],
                         "split":  "train",
                         "difficulty":  "medium"
                     }
    },
    {
        "id":  "seed:repair/primitive-misuse",
        "instruction":  "Identify and fix the primitive misuse.",
        "input":  "Relations: CONSTRAINT(predator, chase_target=prey, speed=2).",
        "output":  "Problem: chasing is a state transition, not a boundary. Use DYNAMICS. Corrected: DYNAMICS(predator, chase_target=prey, speed=2). Keep CONSTRAINT only for bounds or limits if needed.",
        "metadata":  {
                         "source":  "Relational Primitives/Ecosystem demo.md",
                         "tags":  [
                                      "repair",
                                      "dynamics",
                                      "constraint"
                                  ],
                         "split":  "train",
                         "difficulty":  "easy"
                     }
    },
    {
        "id":  "seed:meta/rules-about-rules",
        "instruction":  "Describe how META operates in the ecosystem demo.",
        "input":  "",
        "output":  "META watches GUI events and relation outcomes to create or modify relations/entities. Example: on button click, META creates a new Prey or Predator entity, attaches ONTOLOGY kind, sets GEOMETRY position, CONSTRAINT bounds, and DYNAMICS/EPISTEMIC relations. META can also spawn hunting relations on-the-fly between new predators and existing prey.",
        "metadata":  {
                         "source":  "Relational Primitives/Ecosystem demo.md",
                         "tags":  [
                                      "meta",
                                      "ontology",
                                      "geometry",
                                      "constraint",
                                      "dynamics",
                                      "epistemic"
                                  ],
                         "split":  "train",
                         "difficulty":  "medium"
                     }
    }
]
