{"id": "seed:meta/rules-about-rules", "instruction": "Describe how META operates in the ecosystem demo.", "input": "", "output": "META watches GUI events and relation outcomes to create or modify relations/entities. Example: on button click, META creates a new Prey or Predator entity, attaches ONTOLOGY kind, sets GEOMETRY position, CONSTRAINT bounds, and DYNAMICS/EPISTEMIC relations. META can also spawn hunting relations on-the-fly between new predators and existing prey.", "metadata": {"source": "Relational Primitives/Ecosystem demo.md", "tags": ["meta", "ontology", "geometry", "constraint", "dynamics", "epistemic"], "split": "seed", "difficulty": "medium", "tier": "seed"}}
{"id": "seed:meta/auto-linking", "instruction": "Explain a META rule that auto-adds hunting relations when new prey appear.", "input": "", "output": "META listens for ONTOLOGY(kind=Prey) creations. When a new prey q_new appears, META creates GEOMETRY(predator near q_new, radius=80), EPISTEMIC(predator senses q_new), and DYNAMICS(predator, chase_target=q_new) for each predator. This keeps the hunting graph updated without manual wiring.", "metadata": {"source": "Relational Primitives/Ecosystem demo.md", "tags": ["meta", "ontology", "geometry", "epistemic", "dynamics"], "split": "seed", "difficulty": "medium", "tier": "seed"}}
{"id": "seed:meta/occlusion-graph", "instruction": "Describe a META rule that builds visibility graphs when walls change.", "input": "", "output": "META watches GEOMETRY changes to occluder entities (walls). On change, META rebuilds EPISTEMIC visibility relations: for each agent pair, if line-of-sight is clear per current GEOMETRY, set EPISTEMIC(agent sees target, radius=los_distance); otherwise remove that sensing relation. This keeps epistemic knowledge consistent with geometry edits.", "metadata": {"source": "Constructed", "tags": ["meta", "geometry", "epistemic"], "split": "seed", "difficulty": "medium", "tier": "seed"}}
{"id": "seed:meta/conservation-guard", "instruction": "Describe a META rule that enforces conservation when dynamics update energy.", "input": "", "output": "META hooks DYNAMICS updates to energy. After each step, it sums energy across entities and checks CONSTRAINT(total_energy == baseline). If violated, META adjusts a global reservoir entity to compensate, or rejects the violating DYNAMICS update. This is a rule-about-rules ensuring conservation constraints hold.", "metadata": {"source": "Constructed", "tags": ["meta", "constraint", "dynamics", "ontology"], "split": "seed", "difficulty": "medium", "tier": "seed"}}
{"id": "seed:meta/safety-throttle", "instruction": "Describe a META rule that throttles actuation when safety constraints are breached.", "input": "", "output": "META monitors CONSTRAINT(safety_ok) on actuators. If safety_ok=False, META disables or caps DYNAMICS commands (e.g., velocity<=0) and injects CONSTRAINT(no_actuation=True) until safety_ok=True. When cleared, META restores original DYNAMICS. This keeps actuation rules bound to safety constraints.", "metadata": {"source": "Constructed", "tags": ["meta", "constraint", "dynamics", "ontology"], "split": "seed", "difficulty": "medium", "tier": "seed"}}
{"id": "seed:meta/schema-enforcer", "instruction": "Describe a META rule that enforces ONTOLOGY schemas on new entities.", "input": "", "output": "META listens for entity creation. For each new entity, it checks ONTOLOGY kind against a schema table; if required relations are missing (e.g., GEOMETRY position, CONSTRAINT bounds), META adds them or rejects the creation. This keeps worlds consistent with declared kinds.", "metadata": {"source": "Constructed", "tags": ["meta", "ontology", "geometry", "constraint"], "split": "seed", "difficulty": "medium", "tier": "seed"}}
{"id": "seed:meta/gco-cycle", "instruction": "Describe the GCO cycle and how it relates to RP primitives.", "input": "", "output": "GCO (Global Closure Operator) wraps the evaluator: Loop (relations fire) \u2192 Null (gating/sync) \u2192 Production (externalized action) \u2192 Closure (enforce coherence) \u2192 Reset. META can host the closure logic; CONSTRAINT resolves conflicts; DYNAMICS/GEOMETRY/EPISTEMIC state is frozen at closure; ONTOLOGY identities are stabilized. Stopping condition: GCO fires only on production events, then resets for the next loop.", "metadata": {"source": "Relational Primitives/GCO Log Synthesis.md", "tags": ["meta", "constraint", "dynamics", "geometry", "epistemic", "ontology"], "split": "seed", "difficulty": "medium", "tier": "seed"}}
{"id": "seed:meta/gco-stop-condition", "instruction": "Describe a META rule that triggers GCO closure when production occurs.", "input": "", "output": "META watches for Production events (e.g., new relation/entity creation or external act). When triggered, it enters Closure: halts further relation firing, applies CONSTRAINT to resolve conflicts, commits ONTOLOGY/DYNAMICS state, and emits a reset signal for the next loop. This teaches the model when to stop stepping and finalize state.", "metadata": {"source": "Relational Primitives/GCO Log Synthesis.md", "tags": ["meta", "constraint", "dynamics", "ontology"], "split": "seed", "difficulty": "medium", "tier": "seed"}}
{"id": "seed:meta/gco-contradiction", "instruction": "Apply GCO to handle contradictory ONTOLOGY assignments.", "input": "ONTOLOGY(a, kind=Prey)\nONTOLOGY(a, kind=Predator)", "output": "GCO detects contradictory identity for entity a. Closure requires a consistent ONTOLOGY: choose one kind or escalate to META for resolution. Minimal canonical outcome: one ONTOLOGY assignment; conflicting one removed or flagged.", "metadata": {"source": "Constructed", "tags": ["meta", "ontology", "constraint"], "split": "seed", "difficulty": "easy", "tier": "seed"}}
{"id": "seed:meta/gco-redundancy", "instruction": "Apply GCO to prune redundant relations.", "input": "GEOMETRY(a near b, radius=10)\nGEOMETRY(a near b, radius=10)", "output": "GCO sees duplicate GEOMETRY relations with identical payloads. Closure keeps one canonical relation and removes the redundant copy. No state change beyond deduplication.", "metadata": {"source": "Constructed", "tags": ["meta", "geometry", "constraint"], "split": "seed", "difficulty": "easy", "tier": "seed"}}
{"id": "seed:meta/gco-fixed-point", "instruction": "Check if the relational set is already in closure.", "input": "GEOMETRY(a near b, radius=10)\nDYNAMICS(a, speed=1)", "output": "No contradictions, no duplicates, no unresolved dependencies. GCO reports closure achieved; state is a fixed point for this tick. No META intervention required.", "metadata": {"source": "Constructed", "tags": ["meta", "geometry", "dynamics"], "split": "seed", "difficulty": "easy", "tier": "seed"}}
{"id": "seed:meta/gco-meta-needed", "instruction": "Show when GCO requires META intervention to resolve ambiguity.", "input": "ONTOLOGY(a, kind=Vehicle)\nDYNAMICS(a, velocity=1)\nCONSTRAINT(a, max_velocity=0.5)", "output": "GCO finds conflict between DYNAMICS velocity and CONSTRAINT max_velocity. Closure cannot pick a resolution; it flags META to adjust (clamp velocity) or reject the violating DYNAMICS. Outcome depends on META policy; closure pending until resolved.", "metadata": {"source": "Constructed", "tags": ["meta", "constraint", "dynamics", "ontology"], "split": "seed", "difficulty": "medium", "tier": "seed"}}
